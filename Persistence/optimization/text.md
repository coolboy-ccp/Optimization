# 字符串匹配

## 搜索
建立标准化字符串，搜索时使用高效的谓词来匹配标准化的字符串
```
let str = "Béziers"
let normalizedStr = "beziers"

let predicate = NSPredicate(format: "%K BEGINSWITH[n] %@", normalizedKey, normalizedForSearch)
```

## 排序
### 针对小数据，且不会频繁更改的排序
```
let sd = NSSortDescriptor(key: #keyPath(City.name), ascending: true) 
request.sortDescriptors = [sd]
```
### 将排序完的城市列表保存在内存中，需要手动保持已排序
列表中的数据和持久化存储中的数据同步。
1. 更新已排序数组：

如果我们更改了这个城市数组，或是更改了某个城市的名字，那么我们需要重新排序这个数组。 首先，我们要检测是否有城市被插入或者更改了。这可以通过监听 .NSManagedObjectContextObjectsDidChange 通知来实现。同时，因为别的框架也有可能会 使用 Core Data，我们还需要检测这个通知所对应的上下文是否是和排序相关的。在确认上下 文后，我们可以来看下上下文中那些被插入和修改的对象。如果有新的 City 对象被插入，那么 就需要重新排序。同样地，如果有任何 City 对象的 name 属性被更改了，我们也需要重新排序。

对于通知中的那些被插入的对象，我们可以通过检测对象的实体来进行筛选，来确认是否有 City 对象被插入。同样地，我们也需要从通知中筛选出那些被更新的城市对象，它们很有可能 就是那些在另一个上下文中被更改的对象。一旦我们将这个通知合并到当前的上下文中，这些 对象就会被更新。最后，我们需要检测这些被更改的对象中是否有城市对象并且这些城市的 name 属性被更改了。

2. 持久化

由于针对本地化字符串的排序操作相对来说比较昂贵，所以直接将已排序的数组持久化可能是 一个更好的选择。但是值得事先指出的是，数组中元素的排序顺序在不同版本的 Foundation 框架下，并不能保证是完全一致的。而且如果用戶更改了系统的语言区域，那么我们还是得重 新排序这个数组。

想要持久化一个已排序的数组最简单的方法是，创建拥有有序的对多 (ordered to-many) 关系 的所有者实体 (owner entity)，这个关系指向的就是我们想要排序的实体。因此在我们的示例中 需要创建一个已排序的城市所有者 (SortedCityOwner) 实体，这个实体包含了一个指向城市的 有序对多关系。不过这样一来，由于需要保证这个关系两头的数据始终是最新的，城市的插入 和更改操作就会变得更昂贵。但是在应用启动后获取一个已排序的城市数组就变得非常快了。 这是一个经典的权衡，我们需要在获取数据的开销和插入或更新数据的开销之间做出取舍。
如果我们使用了一个有序的对多关系，那么在之前那个用来追踪更改的逻辑中就可以忽略那些
被更新的对象。因为如果某个上下文将更改合并到了另一个上下文，那么这个新近被排序的关
系也同样会被合并。
SortedCityOwner 是一个伪单例 (每个上下文中有一个)。在性能这一章中有一部分内容叫类似
单例的对象，其中描述了如何高效地使用这些伪单例。上面提到的那个 CitiesSortedByName
类中就需要添加一些逻辑来更新这个伪单例中的对象的顺序。
